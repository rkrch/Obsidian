10. 
11. Подход к проектированию конвейерного процессора на примере архитектуры RISC-V. Сравнение с другими подходами к реализации микроархитектуры.

**Подход и пару слов:**

·     Размещение регистров, стадий, между функциональными блоками процессора. Таким образом сокращается критический путь -> можно поднять частоту.

·     Следующая инструкция продвигается в конвейере, как только предыдущая освободила соответствующую стадию. Таким образом поднимается пропускная способность всей системы: инструкции завершают свою работу за каждый такт. Чем это отличается от однотактного? Как было сказано, здесь частота выше, потому инструкции хоть и завершаются каждый такт, как в однотактном, но этот самый такт в конвейерном процессоре меньше по времени.

· Латентность, то есть время выполнения, одной инструкции выше, чем, к примеру, в однотактном.

·     Инструкции спокойной могут быть друг от друга зависимыми. Как пример, так называемый конфликт по данным RAW (read after write): вторая инструкция просит данные из регистра, а первая, в свою очередь, должна была в него записать, но ещё не успела, поскольку сама ещё не закончила работу. Потому подобные конфликты конвейера необходимо разрешать

Берём за основу однотактный процессор

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

И просто впихнём в него регистры, стадии. На лекции рассмотрели построение конвейерного процессора на 5 ступенях.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

Но возникают некоторые проблемы, как в случае с битами [11:7] декодированной инструкции. Как проявляется проблема? Исходя из рисунка снизу, команда на стадии WB хочет записать данные, единичку, в регистр a0, но запишет в t1, поскольку биты [11:7], приходящие на вход регистра A3, заняты инструкцией add.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

Как этого избежать? Задержать эти биты вместе с инструкцией, пропустив через все следующие стадии конвейера.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

Далее добавим Main Decoder, сигналы которого также задержим, пропустив через необходимые ступени конвейера, чтобы сигналы от него действовали лишь в нужный момент.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

Но существуют так называемые конфликты конвейера: структурные, по данным, по управлению. И для их решения где-то будем пробрасывать сигналы из одной стадии в другую, где-то пускать пузырьки в конвейер и т.д. И управление всем этим будет происходит с помощью Hazard Unit.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

Итоговая

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

Теперь нужно бы подвести итоги в производительности.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

(опечатка: вместо «Многотактный” нужно “Конвейерный”)

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)

**Сравнение:**

Многотактный процессор схож с конвейерным процессором тем, что в него добавляются “кое-какие” регистры. Но общая работа схемы отличается от конвейера:

инструкции не идут одна за другой. Потому нет конфликтов, как, собственно, и в однотактном. Так что отличительная особенность в построении конвейерного процессора от остальных в том, что необходимо обеспечить обнаружение и устранение конфликтов.

Сравнение производительности с другими микроархитектурами, реализованными в рамках курса лекций.

![](file:///C:/Users/kravr/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg)