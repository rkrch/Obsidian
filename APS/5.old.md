Компиляция программ с языков высокого уровня в машинные коды (представления условных операторов, циклов и вызова подпрограмм на примере языка ассемблера RISC-V). Трансляция, ассемблирование, компоновка
![[Pasted image 20260105171118.png]]

RISC-V инструкции:

1. Вычислительные (вып. арифметические и логические операции над операндами в регистрах):

- Инструкции register-register (2 источника регистров операндов, 1 регистр назначения) op dest, scr1, scr2

- Инструкции  register-immediate (один операнд в регистре, второй - маленькая константа, закодированная в инструкции (константу устанавливает программист на этапе написания программы))

op dest, scr1, const

2. Загрузки и сохранения (load and store)

- lw dest, offset(base) - берем данные из осн. памяти по адресу, который рассчитывается: значение их регистра base и прибавляем к нему константу offset и кладем в dest. Получившаяся сумма - адрес памяти.
- sw src, offset(base) - берем данные из регистра src и помещем в память по адресу offset(base)    
- Адрес указывается как пара <Базовый адрес, смещение>. Базовый адрес всегда в регистре, смещение задается константой.
2. Управления 
    Безусловный переход (просто произошел переход без всякого условия
    
jal label и jalr register
- Условный переход (если условие вып., то переходим, если не вып., то не переходим и вып. след. в памяти инструкция)
comp src1, src2, label (label - куда мы переходим, если условие вып.)

2. Псевдоинструкции (представители верхних трех, но имеющий спец. псевдоним, чтобы было проще писать на языке ассемблера  
![[Pasted image 20260105171154.png]]
это тоже для понимания на всякий 

RISC (Reduced Instruction Set Computer) – это архитектура с сокращенным набором команд, которая ориентирована на простоту реализации, из-за чего поддерживает, в основном, не более сотни команд, кодируемых словами фиксированной длины, и использующей всего несколько способов адресации операндов, но выполнять операции можно только с данными из регистрового файла, в связи с чем необходимо применять специальные команды пересылки данных между основной памятью и процессором.

В подавляющем большинстве случаев, современные программы пишутся на языках высокого уровня. Процессоры не понимают языков высокого уровня, поэтому компиляторы переводят текст (программу), написанный на языке высокого уровня в последовательность простых инструкций языка ассемблера. После этого, программу на языке ассемблера переводят в последовательность машинных команд — то, что понятно процессору.

![[Pasted image 20260105171221.png]]
Разница терминологии: 

- В случае языка высокого уровня мы переходим к следующей инструкции, которая лежит внутри, если условие выполнилось.
    
- В случае ассемблера все наоборот. Если условный переход выполняется , значит мы перепрыгиваем через тело условия, т.е. мы его не выполним. Это означает, что условие, которое здесь вычисляется должно быть противоположно условию из С.
    
![[Pasted image 20260105171239.png]]
![[Pasted image 20260105171247.png]]

Примеры ассемблера (разбор разницы - она в том, как происходят переходы): 

1. Все наоборот (для того, чтобы остаться в теле цикла, вычисленное условие должно не выполниться)    
2. Абсолютно такая же логика, как и у языка высокого уровня (чтобы остаться в теле цикла, вычисленное условие должно выполниться)     
![[Pasted image 20260105171258.png]]
На картинке у нас условный переход и цикл вместе 

Если мы хотим использовать код с циклами и условным переходом многократно, тогда используются процедуры (они же подпрограммы, функции)

![[Pasted image 20260105171317.png]]
![[Pasted image 20260105171330.png]]
Вызывающая подпрограмма - та, которая вызывает.
Вызываемая - та, которую вызывают.

Проблема состоит в том, чтобы после использования процедуры данные в регистровом файле сохранились, как до использования процедур.

Тот, кого вызвали, перед тем, как что-то “испортить”, должен взять регистры и их значения положить в основную память, и тогда это будет гарантировать, что с ними ничего не произойдет. Дальше он регистровый файл использует и после этого будет возвращать управление обратно, возьмет данные из основной памяти и разместит их обратно в регистровом файле.

  

Дальше 3 слайда для понимания:
![[Pasted image 20260105171348.png]]
![[Pasted image 20260105171401.png]]
![[Pasted image 20260105171414.png]]
![[Pasted image 20260105171424.png]]

Активационная запись (входной аргумент, адрес возврата, результат, которые компилятор не смог поместить в регистровый файл, пространство для сохранения значений регистров вызывающей процедуры, если они будут использоваться)

Стек – способ организации памяти, при котором слово данных, записанное последним, при считывании будет доступно первым (Last In, First Out, LIFO).
![[Pasted image 20260105171443.png]]
По принципу первый пришел - последний вышел (LIFO)

push - когда в стек что-то записывают, положить информацию
pop - снять верхнюю информацию
  ![[Pasted image 20260105171500.png]]

RISK-V Stack как реализован:

- Стек хранится в памяти (основной), т.е. нужен регитср, указывающий на него (так, чтобы можно было этот стек найти)
-  В RISK-V указатель на стек - это sp (stack pointer - по идее это регистр)
- Стек растет снизу-вверх к младшим адресам.
- sh уменьшает адес
-  pop увеличивает адрес
- sp указывает на вершину стека (на последний записанный элемент)    
- Стек можно использовать в любое время, но возвращать его нужно бнз измерений (т.е. таким же, когда нам его отдали)

![[Pasted image 20260105171522.png]]
Компиляция программ с языков высокого уровня происходит в несколько этапов. Сначала высокоуровневый код компилируется в код на языке ассемблера, который затем ассемблируется в машинный код и сохраняется в виде объектного файла. Компоновщик, также называемый редактором связей или линкером (linker), объединяет полученный объектный код с объектным кодом библиотек и других файлов, в результате чего получается готовая к исполнению программа. На практике, большинство компиляторных пакетов выполняют все три шага: компиляцию, ассемблирование и компоновку. Наконец, загрузчик загружает программу в память и запускает её.
![[Pasted image 20260105171614.png]]
Ассемблирование - это процесс преобразования исходного кода на языке ассемблера в машинный код, который может быть выполнен процессором. Для ассемблирования программы на языке ассемблера RISC-V требуется использовать специальные ассемблеры, которые понимают инструкции этой конкретной архитектуры.

 Процесс ассемблирования включает в себя преобразование мнемоник ассемблерных инструкций в бинарный формат, понятный процессору архитектуры RISC-V.

Компоновка (linking) - это процесс объединения объектных файлов, полученных в результате компиляции программы, в единый исполняемый файл или динамическую библиотеку. 

Этот процесс включает в себя создание таблиц символов, разрешение зависимостей, вычисление адресов функций и переменных, а также создание заголовков и других структур данных, необходимых для работы программы.

Трансляция - процесс преобразования программы на высокоуровневом языке программирования в эквивалентную программу на низкоуровневом языке, как, например, трансляция программы на языке ассемблера в машинный код.

  

